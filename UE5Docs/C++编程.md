# UE5 C++ 编程

## UE 反射系统

### 接口

- 接口声明
  - 声明接口类与声明普通的虚幻类相似，但仍有两个主要区别。首先，接口类使用UINTERFACE宏而不是UCLASS宏，且直接从"UInterface"而不是"UObject"继承。
    - 其次，UINTERFACE类不是实际的接口；它是一个空白类，它的存在只是为了向虚幻引擎反射系统确保可见性。将由其他类继承的实际接口必须具有相同的类名，但是开头字母"U"必须改为"I"。

  ```cpp
    UINTERFACE([specifier, specifier, ...], [meta(key=value, key=value, ...)])
    class UClassName : public UInterface
    {
        GENERATED_BODY()
    };
  ```

- 在C++中实现接口
  - 若要在一个新的类中使用你的接口，只需从"前缀为I（I-prefixed）"的接口类继承（除了你正在使用的任何基于"UObject"的类）即可。

### 对象

- UCLASS 宏
  - UCLASS 宏为 UObject 提供了一个 UCLASS 引用，用于描述它在虚幻引擎中的类型。每个 UCLASS 都保留一个称作 类默认对象（Class Default Object）的对象，简称CDO。CDO 本质上是一个默认"模板"对象，由类构建函数生成，之后就不再修改。
  - 你可以为指定对象获取其 UCLASS 和 CDO，虽然它们通常都是只读类型。 使用 GetClass() 函数即可随时访问对象实例的 UCLASS。

- UObject 创建
  - NewObject：使用所有可用创建选项的可选参数创建一个新实例。提供极高的灵活性，包括带自动生成命名的简单使用案例。
  - CreateDefaultSubobject：创建一个组件或者子对象，可以提供创建子类和返回父类的方法。

- UObjects 提供的功能
  - 此系统的使用不为强制要求，甚至有时不适合使用，但却存在以下益处：
    - 垃圾回收
    - 引用更新
  - 当PendingKill默认禁用时，开发者不需要担心引用更新，这一行可以在该UE版本中移除。
    - 反射
    - 序列化
    - 默认属性变化自动更新
    - 自动属性初始化
    - 自动编辑器整合
    - 运行时类型信息可用
    - 网络复制

- 对象头文件格式

  ```cpp
    #pragma once

    #include 'Object.h'
    #include 'MyObject.generated.h'

    UCLASS()
    class MYPROJECT_API UMyObject : public UObject
    {
        GENERATED_BODY()

    };
  ```

- 销毁对象
  - 对象不被引用后，垃圾回收系统将自动进行对象销毁。这意味着没有任何 UPROPERTY 指针、引擎容器、TStrongObjectPtr 或类实例会拥有任何对它的强引用。
  - 垃圾回收器运行时，寻找到的未引用对象将被从内存中移除。
    - Object->MarkPendingKill() 被 Obj->MarkAsGarbage() 所替代。这个新的函数现在仅用于追踪旧对象。如果 gc.PendingKillEnabled=true ，那么所有标记为 PendingKill 的对象会被垃圾回收器自动清空并销毁。
    - 强引用会将 UObject 保留。如果你不想让这些引用保留 UObject，那么这些引用应该转换来使用弱指针，或者变为一个普通指针由程序员手动清除（如果对性能有较高要求的话）。
    - 如果禁用了 PendingKill()， MarkGarbage() 将会提醒对象的所有者该对象将要被销毁，但是对象本身直到所有对它的引用都解除之后才会被垃圾回收。
    - 对于 Actor，即使 Actor 被调用了 Destroy()，并且被从关卡中移除，它还是会等到所有对它的引用都解除之后才会被垃圾回收。
    - 已有的用于 nullptr 的检查应该被 IsValid() 调用所替代，除非你进行手动清除，因为指针不再会被垃圾回收器通过 MarkPendingKill() 自动清除。

- 序列化
  - 当`UObject`被序列化时，所有`UProperty`值都将被自动写入或读取，除非显式标记为"瞬时"或无法从后构造函数默认值进行更改。例如，你可以在关卡中放入`AEnemy`实例，将其"体力（Health）"设置为500，保存并成功地重新加载，而不必在`UClass`定义之外编写一行代码。
  - 当添加或删除UProperties时，系统会无缝处理加载预先存在的内容。新属性从新的CDO复制默认值。删除的属性将会被静默忽略。
  - 如果需要自定义行为，则可以覆盖`UObject::Serialize`函数。这对于检测数据错误，检查版本号或执行自动转换或更新（如果数据格式有所更改）十分有用。

- 运行时类型信息和类型转换
  - 由于`UObject`是虚幻引擎反射系统的一部分，它们始终知道它们是哪些`UClass`，并可以在运行时做出有关类型的决定和类型转换。
  - 在原生代码中，每个`UObject`类都将自定义`Super`类型定义设置为其父类，从而可以轻松控制覆盖行为。

### 属性

- 属性声明
  - 属性使用标准的C++变量语法声明，前面用UPROPERTY宏来定义属性元数据和变量说明符。

  ```cpp
    UPROPERTY([specifier, specifier, ...], [meta(key=value, key=value, ...)])
    Type VariableName;
  ```

- 字符串
  - 支持三种核心类型的字符串。
    - FString是典型的"动态字符数组"字符串类型。
    - FName是对全局字符串表中不可变且不区分大小写的字符串的引用。相较于FString，它的大小更小，更能高效的传递，但更难以操控。
    - FText是指定用于处理本地化的更可靠的字符串表示。
    - 对于大多数情况下，虚幻依靠TCHAR类型来表示字符。TEXT()宏可用于表示TCHAR文字。

### 结构体

- 结构体（Struct） 是一种数据结构，帮助你组织和操作相关属性。在虚幻引擎中，结构体会被引擎的反射系统识别为 UStruct，但不属于 UObject生态圈,且不能在UClasses的内部使用。
  - 在相同的数据布局下， UStruct 比 UObject 能更快创建。UStruct支持UProperty, 但它不由垃圾回收系统管理，不能提供UFunction。

  ```cpp
    USTRUCT([Specifier, Specifier, ...])
    struct FStructName
    {
        GENERATED_BODY()
    };
  ```

### TSubclassOf

- TSubclassOf 是提供 UClass 类型安全性的模板类。

### 元数据说明符

- 声明类、接口、结构体、列举、列举值、函数，或属性时，可添加 元数据说明符 来控制其与引擎和编辑器各方面的相处方式。每一种类型的数据结构或成员都有自己的元数据说明符列表。
  - 要添加元数据说明符，需使用单词 meta，后接说明符列表。如有必要，可以将它们的值添加到 UCLASS、UENUM、UINTERFACE、USTRUCT、UFUNCTION 或 UPROPERTY 宏

### UFunction

- UFunction声明
  - UFunction 是虚幻引擎（UE）反射系统可识别的C++函数。UObject 或蓝图函数库可将成员函数声明为UFunction，方法是将 UFUNCTION 宏放在头文件中函数声明上方的行中。宏将支持 函数说明符 更改虚幻引擎解译和使用函数的方式。

  ```cpp
    UFUNCTION([specifier1=setting1, specifier2, ...], [meta(key1="value1", key2, ...)])
    ReturnType FunctionName([Parameter1, Parameter2, ..., ParameterN1=DefaultValueN1, ParameterN2=DefaultValueN2]) [const];
  ```

### UE 智能指针

- UE 指针库 为C++11智能指针的自定义实现，旨在减轻内存分配和追踪的负担。该实现包括行业标准 共享指针、弱指针 和 唯一指针。其还可添加 共享引用，此类引用的行为与不可为空的共享指针相同。虚幻Objects使用更适合游戏代码的单独内存追踪系统，因此这些类无法与 UObject 系统同时使用。

- Shared Pointers，共享指针拥有其引用的对象，无限防止该对象被删除，并在无共享指针或共享引用引用其时，最终处理其的删除。共享指针可为空白，意味其不引用任何对象。任何非空共享指针都可对其引用的对象生成共享引用。

- Shared References，共享引用的行为与共享指针类似，即其拥有自身引用的对象。对于空对象而言，其存在不同；共享引用须固定引用非空对象。共享指针无此类限制，因此共享引用可固定转换为共享指针，且该共享指针固定引用有效对象。要确认引用的对象是非空，或者要表明共享对象所有权时，请使用共享引用。
  - 在共享引用和共享指针间选择时，除非需要空白或可为空的对象，否则共享引用为优先选项。如需可能空白或可为空的引用，则应使用共享指针。

- Weak Pointers，弱指针类与共享指针类似，但不拥有其引用的对象，因此不影响其生命周期。此属性中断引用循环，因此十分有用，但也意味弱指针可在无预警的情况下随时变为空。因此，弱指针可生成指向其引用对象的共享指针，确保程序员能对该对象进行安全临时访问。
  - 在Set或Map中用作键。弱指针可能会在未通知容器的情况下随时无效，因此共享指针或共享引用更适用于充当键。可安全地将弱指针用作数值。
  - 虽然弱指针提供 IsValid 函数，但是检查 IsValid 无法保证对象在任何时间长度内均可持续有效。线程安全共享指针可能会因另一线程上的活动而随时无效，因此使用线程安全共享指针应尤其注意。Pin 返回的共享指针将使对象在代码将其清除或其超出范围前保持活跃状态，因此 Pin 函数是用于检查的首选方法，此类检查会导致取消引用或访问存储对象。

- Unique Pointers，唯一指针仅会显式拥有其引用的对象。仅有一个唯一指针指向给定资源，因此唯一指针可转移所有权，但无法共享。复制唯一指针的任何尝试都将导致编译错误。唯一指针超出范围时，其将自动删除其所引用的对象。

- Limitations
  - 共享指针与虚幻对象(UObject 及其衍生类)不兼容。引擎具有 UObject 管理的单独内存管理系统，两个系统未互相重叠

## UE 容器

### TArray

- 创建和填充数组
  - 新元素添加到数组时，数组的分配器将根据需要分配内存。当前数组大小超出时，默认分配器将添加足够的内存，用于存储多个新元素。Add 和 Emplace 函数的多数效果相同，细微区别在于：
    - Add（或 Push）将元素类型的实例复制（或移动）到数组中。
    - Emplace 使用给定参数构建元素类型的新实例。
    - 根据经验，可将 Add 用于 trivial 类型，将 Emplace 用于其他类型。

- 移除
  - Remove 函数族用于移除数组中的元素。Remove 函数将根据元素类型的 运算符== 函数移除所有与提供元素等值的元素。
  - 移动过程存在开销。如不需要剩余元素排序，可使用 RemoveSwap、RemoveAtSwap 和 RemoveAllSwap 函数减少此开销。此类函数的工作方式与其非交换变种相似，不同之处在于其不保证剩余元素的排序，因此可更快地完成任务

- 堆
  - TArray 拥有支持二叉堆数据结构的函数。堆是一种二叉树，其中父节点的排序等于或高于其子节点。作为数组实现时，树的根节点位于元素0，索引N处节点的左右子节点的指数分别为2N+1和2N+2。子节点彼此间不存在特定排序。
  - 调用 Heapify 函数可将现有数组转换为堆。此会重载为是否接受谓词，无谓词的版本将使用元素类型的 运算符< 确定排序：

- Slack
  - 可调整数组的大小，因此使用的内存量不同。为避免每次添加元素时重新分配内存，分配器提供的内存通常会超过必要内存，使之后调用 Add 时不会因重新分配内存而降低性能。同样，删除元素通常不会释放内存。此操作会使数组拥有Slack元素，也就是当前未使用的有效预分配元素储存槽。数组中存储的元素量与数组使用分配内存可存储的元素数量间的差值即为数组中的Slack量。
  - 由于默认构建的数组不分配内存，Slack初始为零。使用 GetSlack 函数可找出数组中的Slack量。通过 Max 函数可获取容器重新分配前数组可保存的最大元素数量。GetSlack 等同 Max 和 Num 间的差值：

- 原始内存
  - AddUninitialized 和 InsertUninitialized 函数可将未初始化的空间添加到数组。两者工作方式分别与 Add 和 Insert 函数相同，只是不调用元素类型的构造函数。若要避免调用构造函数，建议使用此类函数。

### TMap

- TMap 与 TSet 类似，它们的结构均基于对键进行散列运算。但与 TSet 不同的是，此容器将数据存储为键值对（TPair<KeyType, ValueType>），只将键用于存储和获取。
  - Map 有两种类型：TMap 和 TMultiMap。两者之间的不同点是，TMap 中的键是唯一的，而 TMultiMap 可存储多个相同的键。在 TMap 中添加新的键值时，若所用的键与原有的对相同，新对将替换原有的对。在 TMultiMap 中，容器可以同时存储新对和原有的对。
  - 与 TArray 不同的是，内存中 TMap 元素的相对排序既不可靠也不稳定，对这些元素进行迭代很可能会使它们返回的顺序和它们添加的顺序有所不同。这些元素也不太可能在内存中连续排列。Map的支持数据结构是稀疏数组，这种数组可有效支持元素之间的空位。当元素从Map中被移除时，稀疏数组中就会出现空位。将新的元素添加到数组可填补这些空位。但是，即便 TMap 不会打乱元素来填补空位，指向Map元素的指针仍然可能失效，因为如果存储器被填满，又添加了新的元素，整个存储可能会重新分配。

- 查询
  - 如果不确定Map中是否包含某个键，可使用 Contains 函数和 运算符[] 进行检查。但这并非理想的方法，因为同一键需要进行两次查找才能获取成功。使用 Find 函数查找一次即可完成这些行为。如果Map包含该键，Find 将返回指向元素数值的指针。如果Map不包含该键，则返回null。在常量Map上调用 Find，返回的指针也将为常量。
  - 或为了确保查询的结果有效，可使用 FindOrAdd 或 FindRef。
    - FindOrAdd 将返回对与给定键关联的值的引用。如果Map中不存在该键，FindOrAdd 将返回新创建的元素（使用给定键和默认构建值），该元素也会被添加到Map。FindOrAdd 可修改Map，因此仅适用于非常量Map。
    - 不要被名称迷惑，FindRef 会返回与给定键关联的值副本；若Map中未找到给定键，则返回默认构建值。FindRef 不会创建新元素，因此既可用于常量Map，也可用于非常量Map。即使在Map中找不到键，FindOrAdd 和 FindRef 也会成功运行，因此无需执行常规的安全规程（如提前检查 Contains 或对返回值进行空白检查）就可安全地调用。
    - 注意由于 FindOrAdd 可向Map添加新条目，因此之前获得的指针（来自 Find）或引用（来自 FindOrAdd）可能会无效。如果Map的后端存储需要扩展以容纳新元素，会执行分配内存和移动现有数据的添加操作，从而导致这一结果。
  - FindKey 函数执行逆向查找，这意味着提供的值与键匹配，并返回指向与所提供值配对的第一个键的指针。搜索Map中不存在的值将返回空键。
    - 按值查找比按键查找慢（线性时间）。这是因为Map按键排序，而非按值排序。此外，如果Map有多个具有相同值的键，FindKey 可返回其中任一键。

- 移除
  - 使用 Empty 或 Reset 函数可将Map中的所有元素移除。Empty 和 Reset 相似，但 Empty 可采用参数指示Map中保留的slack量。

- Slack
  - Slack是不包含元素的已分配内存。调用 Reserve 可分配内存，无需添加元素；通过非零slack参数调用 Reset 或 Empty 可移除元素，无需将其使用的内存取消分配。
  - 使用 Collapse 和 Shrink 函数可移除 TMap 中的全部slack。Shrink 将从容器的末端移除所有slack，但这会在中间或开始处留下空白元素。
    - Shrink 只删除末端的空元素。要移除所有slack，首先应调用 Compact 函数，将空白空间组合在一起，为调用 Shrink 做好准备。

- KeyFuncs
  - 只要类型具有 运算符== 和非成员 GetTypeHash 重载，就可用作 TMap 的键类型，不需要任何更改。但是，您可能需要将类型用作键，而不重载这些函数。在这些情况下，可对 KeyFuncs 进行自定义。为键类型创建 KeyFuncs，必须定义两个typedef和三个静态函数

### TSet

- TSet 类似于 TMap 和 TMultiMap，但有一个重要区别：TSet 是通过对元素求值的可覆盖函数，使用数据值本身作为键，而不是将数据值与独立的键相关联。TSet 可以非常快速地添加、查找和删除元素（恒定时间）。默认情况下，TSet 不支持重复的键，但使用模板参数可激活此行为。

- 查询
  - 如果不确定集合中是否包含某个键，可使用 Contains 函数和 运算符[] 进行检查。但这并非理想的方法，因为同一键需要进行两次查找才能获取成功。使用 Find 函数查找一次即可完成这些行为。如果集合中包含该键，Find 将返回指向元素数值的指针。如果集合不包含该键，则返回null。对常量集合调用Find，返回的指针也将为常量。

- 移除
  - 通过 Remove 函数可按索引移除元素，但仅建议在通过元素迭代时使用：Remove函数会返回已删除元素的数量。如果给定的键未包含在集合中，则会返回0。如果 TSet 支持重复的键，Remove 将移除所有匹配元素。
  - 同样使用 Empty 或 Reset 函数可将集合中的所有元素移除。Empty 和 Reset 相似，但 Empty 可采用参数指示集合中保留的slack量。

## 游戏性框架

### 断言

- UE 提供 assert 等同项的三个不同族系：check、verify 和 ensure。各个功能的行为略有不同，但它们都是开发期间使用的诊断工具，目标大致相同。
  - Check族系最接近基础 assert，因为当第一个参数得出的值为false时，此族系的成员会停止执行，且默认不会在发布版本中运行。
  - 在大部分版本中，Verify族系的行为与Check族系相同。但即便在禁用Check宏的版本中，Verify宏也会计算其表达式的值。这意味着仅当该表达式需要独立于诊断检查之外运行时，才应使用Verify宏。
    - 举例而言，若某个函数执行操作，然后返回 bool 来说明该操作是否成功，则应使用Verify而非Check来确保该操作成功。因为在发布版本中Verify将忽略返回值，但仍将执行操作。而Check在发布版本中根本不调用该函数，所以行为才会有所不同。
  - Ensure族系类似于Verify族系，但可在出现非致命错误时使用。这意味着，若Ensure宏的表达式计算得出的值为false，引擎将通知崩溃报告器，但仍会继续运行。为避免崩溃报告器收到太多通知，Ensure宏在每次引擎或编辑器会话中仅报告一次。若实际情况需要Ensure宏在每次表达式计算得值为false时都报告一次，则使用"Always"版本的宏。

### Gameplay Classes

- 虚幻引擎中的类拥有一个标准化的命名方案，通过首字母或前缀即可立即明了其为哪种类。游戏性类的前缀有：
  - 前缀 `A`：从 可生成的 游戏性对象的基础类进行延伸。它们是 Actor，可直接生成到世界场景中。
  - 前缀`U`：从所有游戏性对象的基础类进行延伸。它们无法被实例到世界场景中，必须从属于 Actor。总体而言，它们是与 组件相似的对象。

- 类头
  - 虚幻引擎中的游戏性类通常拥有单独且唯一的类头文件。通常这些文件的命名与其中定义的类相匹配，减去 A 或 U 前缀，并使用 .h 文件扩展名。因此，AActor 类的类头文件命名为 Actor.h。
  - 在每个游戏性类头文件的顶端，需要包含生成的头文件（自动创建）。因此在 ClassName.h 的顶端必须出现以下行：
    - `#include "ClassName.generated.h"`

- 类声明
  - 类声明定义类的名称、其继承的类，以及其继承的函数和变量。类声明还将定义通过 类说明符 和元数据要求的其他引擎和编辑器特定行为。
  - 类声明的语法如下所示：

  ```cpp
    UCLASS([specifier, specifier, ...], [meta(key=value, key=value, ...)])
    class ClassName : public ParentName
    {
        GENERATED_BODY() // GENERATED_BODY() 宏必须被放置在类体的最前方。
    }
  ```

- 类构造函数
  - UObjects 使用 Constructors 设置属性和其他变量的默认值，并执行其他必要的初值设定。类构造函数通常放置在类实现文件中，如 AActor::AActor 构造函数位于 Actor.cpp 中。
    - 也可以将构造函数内联放置在类头文件中。然而，如果构造函数在类头文件中，UClass 必须结合 CustomConstructor 说明符进行声明，因为这阻止自动代码生成器在header中创建构造函数声明。

- 构造函数格式
  - UObject 构建函数最基本的形式如下所示：
    - 该构造函数初始化类默认对象（CDO），CDO 是类的新实例所基于的原版

    ```cpp
      UMyObject::UMyObject()
      {
          // 在此处初始化 Class Default Object 属性。
      }
    ```

  - 此外还有一个次要构造函数，支持一个特殊的属性调整结构：

    ```cpp
      UMyObject::UMyObject(const FObjectInitializer& ObjectInitializer)
      :Super(ObjectInitializer)
      {
          // 在此处初始化 CDO 属性。
      }
    ```
  - 虽然以上的两个构造函数实际上并不执行任何初始化，但引擎已将所有字段初始化为零、NULL，或其默认构造函数实现的任意值。
  - 不过，构造函数中的任意初始化代码将被应用至 CDO，因此将被复制到引擎中正确创建的对象新实例上，正如 CreateNewObject 或 SpawnActor 所创建的对象实例
  - 被传入构造函数的 FObjectInitializer 参数尽管被标记为 const，但是可通过预设的可变函数进行配置，以覆写属性和子对象。被创建的 UObject 将受到这些变更的影响，这可用于变更注册属性或组件的数值。

### 委托

- 委托 是一种泛型但类型安全的方式，可在C++对象上调用成员函数。可使用委托动态绑定到任意对象的成员函数，之后在该对象上调用函数，即使调用程序不知对象类型也可进行操作。复制委托对象很安全。你也可以利用值传递委托，但这样操作需要在堆上分配内存，因此通常并不推荐。请尽量通过引用传递委托。
- UE 支持三种类型的委托
  - Single
    - 在C++对象上引用和执行成员函数的数据类型。
  - Multicast
    - 多播委托拥有大部分与单播委托相同的功能。它们只拥有对对象的弱引用，可以与结构体一起使用，可以四处轻松复制等等。
    - 就像常规委托一样，多播委托可以远程加载/保存和触发；但多播委托函数不能使用返回值。它们最适合用来 四处轻松传递一组委托。
    - 事件是一种特殊类型的多播委托，它在访问 Broadcast() 、IsBound() 和 Clear() 函数时会受到限制。
  - Dynamic (UObject, serializable)
    - 动态委托可序列化，其函数可按命名查找，但其执行速度比常规委托慢。

## 编写多人游戏

### Actor及其关联连接

### Actor相关性与优先级

- 虚幻引擎（依次）参照以下规则确定玩家的相关 Actor 组。这些测试是在虚拟函数 AActor::IsNetRelevantFor() 中实施。
  - 如果 Actor 是 bAlwaysRelevant、归属于 Pawn 或 PlayerController、本身为 Pawn 或者 Pawn 是某些行为（如噪音或伤害）的发起者，则其具有相关性。
  - 如果 Actor 是 bNetUseOwnerRelevancy 且拥有一个所有者，则使用所有者的相关性。
  - 如果 Actor 是 bOnlyRelevantToOwner 且没有通过第一轮检查，则不具有相关性。
  - 如果 Actor 被附加到另一个 Actor 的骨架模型，它的相关性将取决于其所在基础的相关性。
  - 如果 Actor 是不可见的 (bHidden == true) 并且它的 Root Component 并没有碰撞，那么则不具有相关性，
    - 如果没有 Root Component 的话，AActor::IsNetRelevantFor() 会记录一条警告，提示是否要将它设置为 bAlwaysRelevant=true。
  - 如果 AGameNetworkManager 被设置为使用基于距离的相关性，则只要 Actor 低于净剔除距离，即被视为具有相关性。

- 虚幻引擎采用了负载平衡技术来安排所有 Actor 的优先级，并根据它们对游戏的重要性为其分别提供一个公平的带宽份额。
  - 每个 Actor 都有一个名为 NetPriority 的浮点变量。这个变量的数值越大，Actor 相对于其他"同伴"的带宽就越多。和优先级为 1.0 的 Actor 相比，优先级是 2.0 的 Actor 可以得到两倍的更新频度。
  - 计算 Actor 的当前优先级时使用了虚拟函数 AActor::GetNetPriority()。为避免出现饥荒（starvation），AActor::GetNetPriority() 使用 Actor 上次复制后经过的时间 去乘以 NetPriority。同时，GetNetPriority 函数还考虑了 Actor 与观察者的相对位置以及两者之间的距离。

### Actor 的 Role 和 RemoteRole 属性

- 在 Actor 的复制过程中，有两个属性扮演了重要角色，分别是 Role 和 RemoteRole。
  - 要确定当前运行的引擎实例是否有主控者，需要查看 Role 属性是否为 ROLE_Authority。如果是，就表明这个运行中的 虚幻引擎 实例负责掌管此 actor（决定其是否被复制）。
  - 如果 Role 是 ROLE_Authority，RemoteRole 是 ROLE_SimulatedProxy 或 ROLE_AutonomousProxy，就说明这个引擎实例负责将此 actor 复制到远程连接。
  - 就目前而言，只有服务器能够向已连接的客户端同步 Actor （客户端永远都不能向服务器同步）。始终记住这一点， 只有 服务器才能看到 Role == ROLE_Authority 和 RemoteRole == ROLE_SimulatedProxy 或者 ROLE_AutonomousProxy。

- 复制模式
  - 服务器不会在每次更新时复制 actor。这会消耗太多的带宽和 CPU 资源。实际上，服务器会按照 AActor::NetUpdateFrequency 属性指定的频度来复制 actor。
  - 因此在 actor 更新的间歇，会有一些时间数据被传递到客户端。这会导致 actor 呈现出断续、不连贯的移动。为了弥补这个缺陷，客户端将在更新的间歇中模拟 actor。
  - `ROLE_SimulatedProxy`
    - 这是标准的模拟途径，通常是根据上次获得的速率对移动进行推算。当服务器为特定的 actor 发送更新时，客户端将向着新的方位调整其位置，然后利用更新的间歇，根据由服务器发送的最近的速率值来继续移动 actor。
    - 使用上次获得的速率值进行模拟，只是普通模拟方式中的一种。您完全可以编写自己的定制代码，在服务器更新的间隔使用其他的一些信息来进行推算。
  - `ROLE_AutonomousProxy`
    - 这种模拟通常只用于 PlayerController 所拥有的 actor。这说明此 actor 会接收来自真人控制者的输入，所以在我们进行推算时，我们会有更多一些的信息，而且能使用真人输入内容来补足缺失的信息（而不是根据上次获得的速率来进行推算）。

### RPC

- 使用 RPC
  - 要将一个函数声明为 RPC，您只需将 Server、Client 或 NetMulticast 关键字添加到 UFUNCTION 声明。
  - 多播 RPC 可以从服务器调用，然后在服务器和当前连接的所有客户端上执行。多播 RPC 还可以从客户端调用，但这时就只能在本地执行。

- 要求和注意事项
  - 必须满足一些要求才能充分发挥 RPC 的作用：
    - 它们必须从 Actor 上调用。
    - Actor 必须被复制。
    - 如果 RPC 是从服务器调用并在客户端上执行，则只有实际拥有这个 Actor 的客户端才会执行函数。
    - 如果 RPC 是从客户端调用并在服务器上执行，客户端就必须拥有调用 RPC 的 Actor。
    - 多播 RPC 则是个例外：
      - 如果它们是从服务器调用，服务器将在本地和所有已连接的客户端上执行它们。
      - 如果它们是从客户端调用，则只在本地而非服务器上执行。
      - 目前为止有一个简单的多播事件限制机制：在特定 Actor 的网络更新期内，多播函数不会复制两次以上。按长期计划，我们会对此进行改善，同时更好的支持跨通道流量管理与限制。

- 验证
  - 在不久前加入了为 RPC 增加验证函数的功能，以此作为检测错误数据/输入的一个手段。其主要思路是：如果 RPC 的验证函数检测到任何参数存在问题，就会通知系统将发起 RPC 调用的客户端/服务器断开。
  - 要为 RPC 声明一个验证函数，只需将 WithValidation 关键字添加到 UFUNCTION 声明语句

### 属性复制

- 每个 Actor 都维护一个全属性列表，其中包含 Replicated 说明符标记的属性
  - 每当复制的属性值发生变化时，服务器会向所有客户端发送更新。客户端会将其应用到Actor的本地版本上。这些更新只会来自服务器，客户端永远不会向服务器或其他客户端发送属性更新。
  - Actor属性复制可靠。这意味着，Actor的客户端版本的属性最终将反映服务器上的值，但客户端不必接受服务器上某个属性的每一个单独变更。例如，如果一个整数属性的值快速从100变成200，然后又变成了300，客户端将最终接受一个值为300的变更，但客户端不一定会知道这个值曾经变成过200。

- 网络更新优化
  - 数据驱动型网络更新频率
    - Actor将观察在其"NetUpdateFrequency"变量中设置的最大更新频率。通过在不太重要或不太频繁变化的Actor上降低该变量，网络更新可以变得更高效，同时在有限带宽的场景中可能会带来更流畅的游戏体验。
    - 常见的更新频率值为：对于重要且不可预知的Actor，例如在射击游戏中由玩家控制的角色，为10（每0.1秒更新一次）；对于行动缓慢的角色，例如在合作类游戏中由AI控制的怪物，为5（每0.2秒更新一次），对于游戏进程不是很重要但仍通过网络同步的以及/或者由服务器端逻辑控制因而需要复制的后台Actor，为2（每0.5秒更新一次）。

- 自适应型网络更新频率
  - 在默认情况下，该功能是关闭的。将控制台变量 net.UseAdaptiveNetUpdateFrequency 设置到 1 可以将其激活。
  - 通过自适应型网络更新频率，可以节省CPU周期，这些CPU周期通常会在没有任何实际更改的情况下多次尝试复制Actor而浪费掉。
  - 当启用了该功能时，系统将根据各个Actor的更新是否有意义，动态调整其更新频率。在该上下文中，"有意义的"更新为初始化了Actor、添加或删除了子对象（即拥有的组件）、或者更改了Actor上或其任何子对象上复制字段值的任何更新。
  - 每个Actor可能的更新速率范围由Actor本身的两个变量决定："NetUpdateFrequency"和"MinNetUpdateFrequency"。"NetUpdateFrequency"表示Actor每秒尝试更新自己的最大次数，而"MinNetUpdateFrequency"表示每秒尝试更新的最小次数。使用该功能可以大大提高复制性能。

#### 条件属性复制

- 默认情况下，每个复制属性都有一个内置条件：如果不发生变化就不会进行复制。
  - 为了加强对属性复制的控制，您可以使用一个专门的宏来添加附加条件。这个宏被称为 DOREPLIFETIME_CONDITION。

#### 复制对象引用

- 一般而言，对象引用会在 UE 多人游戏架构中自动处理。这就是说，如果您有一个已经复制的 UObject 属性，则对该对象的引用将作为服务器分配的专门 ID 通过网络进行发送。这个专门 id 是一个 FNetworkGUID。服务器将负责分配此 id，然后向所有已连接的客户端告知这一分配。
  - 对于通过网络合法引用的对象，必须对其提供支持以保证网络连接。要进行检查，可以调用 UObject::IsSupportedForNetworking()。这通常被认为是一个底层函数，所以一般不需要在游戏代码中对其进行检查。

- 通常可以按照以下原则来确定是否可以通过网络引用一个对象：
  - 任何复制的 actor 都可以复制为一个引用
  - 任何未复制的 actor 都必须有可靠命名（直接从数据包加载）
  - 任何复制的组件都可以复制为一个引用
  - 任何未复制的组件都必须有可靠命名。
  - 其他所有 UObject（非 actor 或组件）必须由加载的数据包直接提供

- 拥有可靠命名的对象
  - 拥有可靠命名的对象指的是存在于服务器和客户端上的同名对象。如果 Actor 是从数据包直接加载（并非在游戏期间生成），它们就被认为是拥有可靠命名。
  - 满足以下条件的组件即拥有可靠命名：
    - 从数据包直接加载
    - 通过简单构建脚本添加
    - 采用手动标记（通过 UActorComponent::SetNetAddressable 进行）
      - 只有当您知道要手动命名组件以便其在服务器和客户端上具有相同名称时，才应当使用这种方法（最好的例子就是 AActor C++ 构造函数中添加的组件）

### 复制子对象















